(function(){"use strict";class ServiceWorkerCache{constructor(cacheName,filesToCache){this.cacheName=cacheName;this.filesToCache=filesToCache}
async onInstall(event){try{const cache=await caches.open(this.cacheName);await cache.addAll(this.filesToCache)}catch(error){console.error("Install error:",error)}}
async onActivate(event){const cacheWhitelist=[this.cacheName];try{const cacheNames=await caches.keys();await Promise.all(cacheNames.map(async(cacheName)=>{if(!cacheWhitelist.includes(cacheName)){await caches.delete(cacheName)}else{const expirationTime=Date.now()-24*60*60*1000;const cache=await caches.open(cacheName);const requests=await cache.keys();await Promise.all(requests.map(async(request)=>{const response=await cache.match(request);if(response){const dateHeader=response.headers.get("date");if(dateHeader&&new Date(dateHeader)<expirationTime){await cache.delete(request)}}}))}}))}catch(error){console.error("Activate error:",error)}}
async onFetch(event){const request=event.request;if(request.method!=="GET"){return}
event.respondWith((async()=>{try{const cacheResponse=await caches.match(request);if(cacheResponse){return cacheResponse}
const networkResponse=await fetch(request);if(networkResponse&&networkResponse.status===200){const cache=await caches.open(this.cacheName);cache.put(request,networkResponse.clone())}
return networkResponse}catch(error){console.error("Fetch error:",error);return new Response("Offline content unavailable",{status:503,headers:{"Content-Type":"text/plain"},})}})())}
async onBeforeInstallPrompt(event){event.preventDefault();try{await event.prompt();const choiceResult=await event.userChoice;if(choiceResult.outcome==="accepted"){console.log("User accepted the install prompt")}else{console.log("User dismissed the install prompt")}}catch(error){console.error("BeforeInstallPrompt error:",error)}}
async onPush(event){const options={body:event.data?event.data.text():"No payload",icon:"/icons/Settings.png",actions:[{action:"open_app",title:"Open App"},{action:"dismiss",title:"Dismiss"},],data:{notificationType:"push"},};event.waitUntil(self.registration.showNotification("Placewith5s",options).catch((error)=>{console.error("Push error:",error)}))}
async onMessage(event){if(event.data&&event.data.type==="SKIP_WAITING"){self.skipWaiting()}else if(event.data&&event.data.type==="updateCache"){if(Array.isArray(event.data.updatedFiles)){await this.updateCache(event.data.updatedFiles)}else{console.warn("Invalid updateCache message:",event.data)}}}
async updateCache(updatedFiles){try{const cache=await caches.open(this.cacheName);await cache.addAll(updatedFiles||this.filesToCache)}catch(error){console.error("Update cache error:",error)}}
handleEvent(event){switch(event.type){case "install":this.onInstall(event);break;case "activate":this.onActivate(event);break;case "fetch":this.onFetch(event);break;case "beforeinstallprompt":this.onBeforeInstallPrompt(event);break;case "push":this.onPush(event);break;case "message":this.onMessage(event);break;default:console.warn(`Unhandled event type: ${event.type}`)}}}
const CACHE_NAME="placewith5s-v1";const FILES_TO_CACHE=["/icons/Settings.png","/icons/Settings.svg","/icons/Policy.svg","/icons/Cookies.svg","/manifest.json","/robots.txt",];const serviceWorkerCache=new ServiceWorkerCache(CACHE_NAME,FILES_TO_CACHE);self.addEventListener("install",serviceWorkerCache);self.addEventListener("activate",serviceWorkerCache);self.addEventListener("fetch",serviceWorkerCache);self.addEventListener("beforeinstallprompt",serviceWorkerCache);self.addEventListener("push",serviceWorkerCache);self.addEventListener("message",serviceWorkerCache)})()